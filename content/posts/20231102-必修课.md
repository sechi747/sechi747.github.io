---
title: "计算机基础补全 [WIP]"
description: ""
uid: 530
createTime: 2023/11/02 17:54:31
updateTime: 2023/11/02 17:54:31
tag: ['计算机基础']
---
:ArticleToc
:ArticleHeader

本文是关于[《程序员的必修课》](https://juejin.cn/book/7196580339181944872?utm_source=course_list)这本小册的简要记录。

## 二进制

N 进制的特点：

1. 最大数字是 N-1，大于 N 就用两位数表示；高位的数字是低位的 N 倍。

2. 任意一个数字，它的大小就是**各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和**。

比如二进制：
$$
abc=a×2 ^2+b×2 ^1+c×2 ^0
$$
之所以采取二进制，是因为计算机底层基于晶体管实现，可以把晶体管理解为开关，1 代表开，0 代表关。

p 与 q 等于取交集，全部为 1 才为 1；p 或 q 等于取并集，全部为 0 才为 0。因此，对于二进制可以得出：
$$
100∩011=000，100∪011=111
$$
如果数 x 是 2 的 n 次方，那么 x 的最高位就是 1，其余位全是 0，所以 x-1 的最高位是 0，其余位都是 1。设 x = 10000，则 x-1 = 01111，也就是说 10000 ∩ 01111 = 0，即 x ∩ (x-1) = 0

```js
// 判断某数是否为 2 的 n 次方
function isPowerOfTwo(n) {
    return n > 0 && ((n & (n - 1)) === 0)
}
```

### 编码（原码、反码、补码）

- `原码`：就是数字本身。比如 1110 的原码就是 1110。
- `反码`：将原码除符号位按位取反就是反码。比如 1110 的反码是 1001。
- `补码`：将反码加 1 就是补码。比如 1110 的反码是 1001，补码就是 1010。

> 正数的原码、反码、补码都相同，都等于原码；负数的反码等于除符号位按位取反，负数的补码等于反码末位加1。

补码的存在是为了简化减法运算（计算机只有加法器，没有减法器），即使用补码可以把减法变成加法。原理就是**数 A 减去数 B 等于数 A 加上数 B 的补码，然后砍掉最高位**。以十进制为例：十进制的补码等于用 9 减去各个位置的数字后末位再加 1，所以 81-21=81+(78+1)=81+79=160，去掉最高位的 1，结果就是 60。

套用到二进制上则是**按位取反，末位再加 1**。

比如 0110 - 0001，-0001 的原码为 1001，补码也就是 1111，换成补码计算就是 0110 + 1111，结果为 10101，去除最高位的结果是 0101，可以看到计算结果是正确的。也就是说 **0110 - 0001 = 0110 +1111**，而 0110 -0001 = 0110 + (-0001)，这也就意味着 -0001 等于 1111。于是我们可以得出这么一条结论：**如果用补码表示二进制，那么高位就表示符号位置：如果高位是 1，就表示负数；如果高位是 0，就表示正数**。所以 1111 就表示负数，它对应的原码等于对它再次求补码，1111 的反码是 1000，补码就是 1001，高位是 1，表示负数，所以就是 -0001，所以就有：1111 = (-0001)

事实上，计算机中所有的数字都是用补码表示，只不过正数的补码等于其原码，所以在一般计算中只需要注意负数就可以了。

### 位运算

#### 按位与 &

将各个数位的数字进行逻辑与，都是 1 才为 1，否则为 0。比如 110&011=010 ，1111&111=0111

**使用与运算可以消除指定位置的数字。也可以判断是否具有某个标记。**

比如如果我们需要取一个 8 位数的高 4 位，就可以让它和 1111 0000 进行按位与运算，运算后它的低 4 位一定是 0，而 高4 位则会保持不变，也就相当于消除了它的低 4 位，只取了它的高 4 位。

```js
const vip = 0b00000001
const svip= 0b00000011

function isVip(flag) {
  return (vip & flag) === vip
}

function isSvip(flag) {
  return (svip & flag) === svip
}

console.log(isVip(0b11111111)) // true
```

#### 按位或 |

将各个数位的数字进行逻辑或，都是 0 才为 0，否则为 1。比如 110∣011=111，1111∣111=1111

**使用或运算可以给指定位置添加标记。**

比如我们要把 0011 1001 的低 4 位全部置为 1，而高 4 位不变，那么就可以 0011 1001|0000 1111=0011 1111

```js
const svip= 0b00000011

function setSvip(flag) {
    return svip | flag
}

console.log(setSvip(0b00000000).toString(2)) // 11 即 00000011
```

#### 异或 ^

将各个位置数字进行异或，相同为 0，不同为 1。比如 1111 ^ 1111 = 0000，0000 ^ 1111 = 1111

**一个数和 0 异或等于它本身。一个数和自身异或等于 0。**

```js
let a = 10
let b = 20

a = a ^ b;
b = a ^ b;
a = a ^ b;

console.log(a, b) // 20,10
```

- `a = a ^ b;` 此时 a 就是 a^b;
- `b = a ^ b;` 也就是 b = (a^b)^b = a^b^b = a^(b^b)；而相同的数字异或等于 0，那就是 a^0，也就是 a，此时 b=a 了。
- `a = a ^ b;` 此时经过第一步运算 a=a^b，经过第二步运算 b=a，所以 a  = a^a^b = 0^b，也就是 b。

```js
function findUniqueNumber(nums) {
   let result = nums[0];
   for (let i = 1; i < nums.length; i++){
       result ^= nums[i];
   }
   return result;
}

console.log(findUniqueNumber([1,3,4,2,6,3,2,1,4])) // 6
```

#### 非 !

将所有位置的数字取反，原来是 0 就变为 1，原来是 1 就变为 0。

#### 左移 <<

将所有数字向左边移动 n 位，右边补 0。

**在 2 进制中，左移动 n 位，就等于乘以 2 的 n 次方倍**。

比如计算 a * 15 时，可以计算为 `a << 4 - a` 

#### 右移 >>

将所有数字向右边移动 n 位，左边补符号位，正数就补 0，负数就补 1。比如：0111>>1=0011，因为是正数，所以左边补 0。

但**对于负数的右移要转为补码来计算**。

比如：要计算-5右移1位，

- 先计算-5的补码，也就是1011
- 执行位运算: 1011>>1=1101，因为1011是负数，所以高位补1
- 再把1101求一次补码，得到原码: 1011，因为1101是负数，所以就是-3。

如何快速计算负数的右移：**先使用正数做右移，完了再转成负数就行了**

比如，还是-5，我们想除以2，我们可以先计算5的右移:

0101>>1=0010，也就是2，也就是0010，我们把最高位符号位改为1，就是1010，也就是-2的原码，这样我们就计算出了-5除以2的结果。

> 正数的右移运算等于做除法，负数的右移不等于做除法。

**在 2 进制中，正数右移 n 位，就等于除以 2 的 n 次方倍**。

#### 无符号右移 >>>

无符号右移跟右移一样，只不过左边永远补 0。比如 1111 0100 >>> 4 = 0000 1111

移位运算分为逻辑移位和算数移位，如果你用二进制表示数值，那么高位就是符号位，此时为算术移位，右移则高位补符号位。如果你用二进制表示逻辑，比如上述的flag，那此时就是逻辑移位，右移则高位永远补0。

## 数据类型

以下类型以 Java 为准

### 值类型

- 比特类型（byte）：8 位二进制。
- 短整型（short int）：16 位二进制。
- 整型（int）：32 位二进制。
- 长整型（long）：64 位二进制。
- 布尔类型（boolean）：默认是使用 int 表示的，也就是 32 位二进制。
- 字符类型（char）：16 位二进制。
- 单精度浮点（float）：32 位二进制。
- 双精度浮点（double）64 位二进制。

其中，我们将 8 位二进制称作一个字节，也就是 1byte，也就是: 1byte = 8bit，也就是 8 个二进制位；因为最高位要用来表示符号位，所以，1 个 byte 的大小范围就是 $[−2^7 \sim 2^7−1]$ 

