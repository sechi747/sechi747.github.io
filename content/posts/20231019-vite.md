---
title: "深入浅出 Vite [WIP]"
description: ""
uid: 529
createTime: 2023/10/19 17:50:31
updateTime: 2023/10/19 17:50:31
tag: ['Vite']
---
:ArticleToc
:ArticleHeader

本文是关于[《深入浅出 Vite》](https://juejin.cn/book/7050063811973218341?utm_source=course_list)这本小册的简要记录。

# 模块标准

`CommonJS`、`AMD`、`CMD`、`UMD`、`ES Module` 

## 无模块化标准

### 文件划分

```js
// module-a.js
let data = "data";
```

``` js
// module-b.js
function method() {
  console.log("execute method");
}
```

```html
// index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="./module-a.js"></script>
    <script src="./module-b.js"></script>
    <script>
      console.log(data);
      method();
    </script>
  </body>
</html>
```

缺点：

1. 模块进行了全局声明和定义，会出现变量名冲突的问题。
1. 变量全都定义在全局，无法直观的看出某个变量属于哪一个模块。
1. 无法清晰地管理模块间的依赖关系和加载顺序。

### 命名空间

```js
// module-a.js
window.moduleA = {
  data: "moduleA",
  method: function () {
    console.log("execute A's method");
  },
};
```

```js
// module-b.js
window.moduleB = {
  data: "moduleB",
  method: function () {
    console.log("execute B's method");
  },
};
```

```html
// index.html
...
  <body>
    <script src="./module-a.js"></script>
    <script src="./module-b.js"></script>
    <script>
      console.log(data);
      method();
    </script>
  </body>
...
```

相较于直接使用文件划分，命名空间可以避免变量名冲突的问题，同时能较为直观地看出某个变量的所属模块。

### IIFE

```js
// module-a.js
(function () {
  let data = "moduleA";

  function method() {
    console.log(data + "execute");
  }

  window.moduleA = {
    method: method,
  };
})();
```

```js
// module-b.js
(function () {
  let data = "moduleB";

  function method() {
    console.log(data + "execute");
  }

  window.moduleB = {
    method: method,
  };
})();
```

```html
// index.html
...
  <body>
    <script src="./module-a.js"></script>
    <script src="./module-b.js"></script>
    <script>
      // 此时 window 上已经绑定了 moduleA 和 moduleB
      console.log(moduleA.data);
      moduleB.method();
    </script>
  </body>
...
```

相较于命名空间，IIFE 的安全性要更高，因为它实现了私有作用域，模块内部的变量只有在模块内部才能够访问，不会被外部环境直接读取或修改。

然而，无论是命名空间还是 IIFE 都无法解决模块依赖和加载顺序的问题。

## CommonJS

最早的模块化规范，同时提供了代码规范和 loader。

```js
// module-a.js
var data = "hello world";
function getData() {
  return data;
}
module.exports = {
  getData,
};

// index.js
const { getData } = require("./module-a.js");
console.log(getData());
```

缺点：

1. 原生提供的 loader 只支持 Node.js 环境，如果想在浏览器中使用则需要依赖 `browserify`。
2. `CommonJS` 本身约定以**同步**的方式进行模块加载，所以在浏览器中使用时会造成**阻塞**。

## AMD

`AMD` 全称为 `Asynchronous Module Definition`，即异步模块定义规范。与 `CommonJS` 不同，它支持异步加载模块。

```js
// main.js
define(["./print"], function (printModule) {
  printModule.print("main");
});

// print.js
define(function () {
  return {
    print: function (msg) {
      console.log("print " + msg);
    },
  };
});
```

但 `AMD` 规范并没有得到浏览器的原生支持，需要第三方 loader 来实现，比如 `requireJS`。

同时期出现的规范还有 `CMD`，它是由淘宝开源的 `SeaJS` 实现的。

而后来的 `UMD` 规范则是兼容 `AMD` 和 `CommonJS` 的一个模块化方案，可以同时运行在浏览器和 Node.js 环境。

## ES Module

`ES Module` 被绝大部分的**现代**浏览器（批评的就是你！IE！)支持。只需要在 script 标签中加入 `type=module` 浏览器就会按照 `ES Module` 来加载模块。

使用方法就不在赘述，天天用。

# Vite

在 Vite 项目中，**每一个 import 语句都代表一个 HTTP 请求**。这是因为 Vite 倡导 `no-buldle` 理念，在开发环境中直接使用 `ES Module` 实现模块加载而不是先整体打包再加载（比如 webpack）。